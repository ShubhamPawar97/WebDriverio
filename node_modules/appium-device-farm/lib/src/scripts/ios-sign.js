"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const fs_1 = __importDefault(require("fs"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const applesign_1 = __importDefault(require("applesign"));
const archiver_1 = __importDefault(require("archiver"));
const readdirAsync = util_1.default.promisify(fs_1.default.readdir);
const unlinkAsync = util_1.default.promisify(fs_1.default.unlink);
const statAsync = util_1.default.promisify(fs_1.default.stat);
const rmdirAsync = util_1.default.promisify(fs_1.default.rmdir);
const execAsync = util_1.default.promisify(child_process_1.exec);
const wdaBuildPath = '/appium_wda_ios/Build/Products/Debug-iphoneos';
function findWebDriverAgentPath() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (process.env.WDA_PROJECT_PATH) {
                console.log('‚úÖ WebDriverAgent project path provided');
                return process.env.WDA_PROJECT_PATH;
            }
            else {
                console.log('üîç Searching for WebDriverAgent.xcodeproj...');
                const { stdout } = yield execAsync('find $HOME/.appium -name WebDriverAgent.xcodeproj');
                const projectPath = stdout.trim();
                console.log('‚úÖ Found WebDriverAgent.xcodeproj at:', projectPath);
                return path_1.default.dirname(projectPath);
            }
        }
        catch (error) {
            console.error('‚ùå Error finding WebDriverAgent.xcodeproj:', error);
            process.exit(1);
        }
    });
}
// 2. Run xcodebuild clean build-for-testing
function buildWebDriverAgent(projectDir) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.log('üèóÔ∏è Building WebDriverAgent...');
            const buildCommand = 'xcodebuild clean build-for-testing -project WebDriverAgent.xcodeproj -derivedDataPath appium_wda_ios -scheme WebDriverAgentRunner -destination generic/platform=iOS CODE_SIGNING_ALLOWED=NO';
            yield execAsync(buildCommand, { cwd: projectDir, maxBuffer: undefined });
            console.log('üéâ Successfully built WebDriverAgent!');
        }
        catch (error) {
            console.error('‚ùå Error building WebDriverAgent:', error);
            process.exit(1);
        }
    });
}
// 3. Search for iPhoneos path inside "appium_wda_ios/Build/Products/"
function findiPhoneosPath() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.log('üîç Searching for iPhoneos path...');
            const wdaPath = yield findWebDriverAgentPath();
            const wdaApp = `${wdaPath}/${wdaBuildPath}/WebDriverAgentRunner-Runner.app`;
            console.log('‚úÖ Found iPhoneos path:', wdaApp);
            return wdaApp;
        }
        catch (error) {
            console.error('‚ùå Error finding iPhoneos path:', error);
            process.exit(1);
        }
    });
}
function deleteFilesInDirectory(directoryPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const files = yield readdirAsync(directoryPath);
            for (const file of files) {
                const filePath = path_1.default.join(directoryPath, file);
                const fileStat = yield statAsync(filePath);
                if (fileStat.isFile()) {
                    yield unlinkAsync(filePath);
                }
                else if (fileStat.isDirectory()) {
                    yield deleteFilesInDirectory(filePath);
                    yield rmdirAsync(filePath);
                }
            }
        }
        catch (error) {
            console.error('‚ùå Error deleting files:', error);
            process.exit(1);
        }
    });
}
function createPayloadDirectory(path) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.log('üìÅ Creating Payload directory...');
            console.log(`mkdir -p ${path}/Payload`);
            yield execAsync(`mkdir -p ${path}/Payload`);
            console.log('‚úÖ Payload directory created successfully.');
        }
        catch (error) {
            console.error('‚ùå Error creating Payload directory:', error);
            process.exit(1);
        }
    });
}
// 2. Move the .app file into the Payload directory
function moveAppFile(appFilePath, payloadPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.log('üöö Moving .app file to Payload directory...');
            const appFileName = path_1.default.basename(appFilePath);
            yield execAsync(`mv ${appFilePath} ${payloadPath}/Payload`);
            console.log(`‚úÖ Moved ${appFileName} to Payload directory.`);
        }
        catch (error) {
            console.error('‚ùå Error moving .app file:', error);
            process.exit(1);
        }
    });
}
// 3. Zip the Payload directory
function zipPayloadDirectory(outputZipPath, folderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const output = fs_1.default.createWriteStream(outputZipPath);
            const archive = (0, archiver_1.default)('zip', { zlib: { level: 9 } });
            output.on('close', () => {
                console.log(`Zipped ${archive.pointer()} total bytes`);
                console.log(`Archive has been written to ${outputZipPath}`);
                resolve();
            });
            archive.on('error', (err) => {
                reject(err);
            });
            archive.pipe(output);
            archive.directory(folderPath, 'Payload');
            archive.finalize();
        });
    });
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!process.env.MOBILE_PROVISION_PATH) {
            console.error('‚ùå Mobile provision file path not provided, available paths:');
            const { stdout } = yield execAsync('find ~/Library/MobileDevice', { encoding: 'utf8' });
            // Output the result to the CLI
            console.log(stdout);
            throw new Error('‚ùå Mobile provision file path not provided, Please set MOBILE_PROVISION_PATH in environment variables');
        }
        const projectDir = yield findWebDriverAgentPath();
        console.log('üìÅ WebDriverAgent project directory:', projectDir);
        yield buildWebDriverAgent(projectDir);
        const iPhoneosPath = yield findiPhoneosPath();
        console.log('üìÇ iPhoneos path found:', iPhoneosPath);
        console.log(`üóëÔ∏è Deleting files in directory: ${iPhoneosPath}/Frameworks`);
        yield deleteFilesInDirectory(`${iPhoneosPath}/Frameworks`);
        yield createPayloadDirectory(`${projectDir}${wdaBuildPath}`);
        yield moveAppFile(iPhoneosPath, `${projectDir}${wdaBuildPath}`);
        yield zipPayloadDirectory(`${projectDir}${wdaBuildPath}/wda-resign.zip`, `${projectDir}${wdaBuildPath}/Payload`);
        const ipaToResign = `${projectDir}${wdaBuildPath}/wda-resign.zip`;
        console.log('‚úÖ Mobile provision file path provided');
        const as = new applesign_1.default({
            mobileprovision: process.env.MOBILE_PROVISION_PATH,
            outfile: `${projectDir}${wdaBuildPath}/wda-resign.ipa`,
        });
        yield as.signIPA(ipaToResign);
        console.info('*******************************************');
        console.info(`‚úÖ Successfully signed ${projectDir}${wdaBuildPath}/wda-resign.ipa`);
        console.info('*******************************************');
    });
}
main();
